# 折旧与摊销估算表合计行计算功能实现计划

## 任务概述
在折旧与摊销估算表modal中，针对资产类别为"合计"的记录项，计算"年折旧/摊销额（万元）"列的数值。

## 计算逻辑
- **计算公式**：年折旧/摊销额 = 原值 ÷ 运营期不为空的单元格个数
- **结果格式**：保留两位小数
- **触发时机**：modal加载时及运营期列数据变化时自动触发更新

## 当前实现分析

### 数据结构（第106-112行）
```typescript
const [depreciationData, setDepreciationData] = useState<Array<{
  序号: string
  资产类别: string
  原值: number
  年折旧摊销额: number
  分年数据: number[]
}>>([])
```

### 当前计算逻辑（第663-759行）
- 使用useEffect监听相关依赖变化
- 计算A、D、E三行的折旧摊销数据
- **合计行在JSX中动态计算渲染**（第1735-1760行）

### 表格渲染（第1704-1760行）
- 使用`depreciationData.map()`遍历渲染各行
- 合计行单独在JSX中计算和渲染，使用`reduce()`进行统计

## 实施方案

### 方案选择
将合计行作为独立记录添加到`depreciationData`数组中，序号为'合计'，实现数据层面的统一计算和渲染。

### 实施步骤

#### 1. 修改数据结构
- 在计算折旧摊销表的useEffect中，将合计行作为一条记录添加到data数组
- 合计行的序号设为'合计'，资产类别为'合计'

#### 2. 实现合计行计算逻辑
```typescript
// 计算合计行的年折旧/摊销额
const totalOriginalValue = data.reduce((sum, row) => sum + row.原值, 0);

// 统计运营期不为空的单元格个数
const nonEmptyYearsCount = data.reduce((count, row) => {
  return count + row.分年数据.filter(val => val > 0).length;
}, 0);

// 计算年折旧/摊销额（保留两位小数）
const totalAnnualDepreciation = nonEmptyYearsCount > 0
  ? Number((totalOriginalValue / nonEmptyYearsCount).toFixed(2))
  : 0;

// 合计行的分年数据
const totalYearlyData = Array.from({ length: operationYears }, (_, i) =>
  data.reduce((sum, row) => sum + row.分年数据[i], 0)
);

// 添加合计行到数据数组
data.push({
  序号: '合计',
  资产类别: '合计',
  原值: totalOriginalValue,
  年折旧摊销额: totalAnnualDepreciation,
  分年数据: totalYearlyData
});
```

#### 3. 修改表格渲染逻辑
- 移除JSX中的动态合计行计算（第1735-1760行）
- 直接使用`depreciationData`中的合计行进行渲染
- 使用`row.序号`作为key，确保渲染稳定性

#### 4. 空值和异常数据处理
```typescript
// 空值兜底
const safeOriginalValue = row.原值 ?? 0;
const safeYearlyData = row.分年Data ?? [];

// 避免除以0
const totalAnnualDepreciation = nonEmptyYearsCount > 0
  ? Number((totalOriginalValue / nonEmptyYearsCount).toFixed(2))
  : 0;
```

#### 5. 确保自动触发更新
- 合计行的计算已在useEffect中，依赖数组包含所有相关字段
- 当运营期数据变化时，useEffect会自动重新计算

## 技术要点

### 遵循编程规范
1. **计算逻辑前置化**：所有计算在useEffect中完成，JSX仅做纯渲染
2. **缓存计算结果**：使用useEffect依赖数组，避免重复计算
3. **保证渲染稳定性**：使用`row.序号`作为key，而非数组索引
4. **空值兜底处理**：对undefined/null数据做默认值处理
5. **禁止修改原始数据**：使用map和展开运算符生成新数据对象

### 关键代码位置
- **计算逻辑**：第663-759行的useEffect
- **表格渲染**：第1704-1760行的Table.Tbody
- **数据状态**：第106-112行的useState定义

## 验证要点
1. 合计行的年折旧/摊销额计算是否正确（原值 ÷ 运营期不为空单元格个数）
2. 计算结果是否保留两位小数
3. modal加载时是否自动计算
4. 运营期数据变化时是否自动更新
5. 空值和异常数据是否正确处理
6. 表格渲染是否稳定（使用正确的key）
