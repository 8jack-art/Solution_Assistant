# 投资估算简表加载优化方案

## 问题描述

从其他页面（如 Dashboard、项目详情页）进入投资估算简表模块时，会连续多次调用数据库加载数据，导致：
- 性能问题：重复的 API 请求增加服务器压力
- 用户体验：页面加载变慢
- 数据一致性：可能获取到不同时间点的数据

## 问题分析

### 根本原因

| 序号 | 原因 | 位置 | 影响 |
|------|------|------|------|
| 1 | 每次都清除缓存 | `InvestmentSummary.tsx:1202` | `dataCache.invalidate()` 导致无法使用缓存 |
| 2 | React StrictMode | 开发环境 | useEffect 被调用两次 |
| 3 | 多个 setTimeout | `InvestmentSummary.tsx:1385` | 多次异步状态更新触发渲染 |
| 4 | 两步 API 调用 | `loadProjectAndEstimate()` | 先项目信息，再投资估算 |

### 当前加载流程

```
用户进入页面
    ↓
useEffect([id]) 执行
    ↓
dataCache.invalidate() ← 清除缓存
    ↓
loadProjectAndEstimate()
    ├── projectApi.getById() ← API 调用 1
    └── investmentApi.getByProjectId() ← API 调用 2
    ↓
setTimeout(setEstimate, 0) ← 状态更新
    ↓
渲染完成
```

## 修复方案

### 方案概述

1. **移除强制缓存清除**：改为有条件清除或使用缓存
2. **添加加载状态锁**：防止并发重复请求
3. **优化状态更新**：减少不必要的 setTimeout
4. **合并 API 调用**：一次请求获取所有必要数据

### 具体修改

#### 1. 修改 useEffect 加载逻辑

**文件**: `client/src/pages/InvestmentSummary.tsx`

**修改前**:
```typescript
useEffect(() => {
  loadCounterRef.current += 1
  console.log(`[数据加载] useEffect执行 #${loadCounterRef.current}, id=${id}`)
  
  if (id) {
    dataCache.invalidate(`investment:${id}`)  // ❌ 强制清除
    loadProjectAndEstimate()
  }
  
  return () => {
    console.log(`[数据加载] useEffect清理 #${loadCounterRef.current}`)
    if (abortControllerRef.current) {
      abortControllerRef.current.abort()
    }
  }
}, [id])
```

**修改后**:
```typescript
// 添加加载状态锁
const isLoadingRef = useRef(false)

useEffect(() => {
  if (!id) return
  
  loadCounterRef.current += 1
  console.log(`[数据加载] useEffect执行 #${loadCounterRef.current}, id=${id}`)
  
  // 防止重复加载
  if (isLoadingRef.current) {
    console.log('[数据加载] 已在加载中，跳过重复请求')
    return
  }
  
  const loadData = async () => {
    isLoadingRef.current = true
    setLoading(true)
    
    try {
      // 尝试从缓存加载（不强制清除）
      const cachedData = dataCache.get(`investment:${id}`)
      if (cachedData) {
        console.log('[数据加载] 使用缓存数据')
        await loadProjectAndEstimate(true) // 传入使用缓存的标志
      } else {
        console.log('[数据加载] 缓存不存在，从服务器加载')
        await loadProjectAndEstimate(false)
      }
    } catch (error) {
      console.error('[数据加载] 失败:', error)
    } finally {
      isLoadingRef.current = false
      setLoading(false)
    }
  }
  
  loadData()
  
  return () => {
    console.log(`[数据加载] useEffect清理 #${loadCounterRef.current}`)
    if (abortControllerRef.current) {
      abortControllerRef.current.abort()
    }
  }
}, [id])
```

#### 2. 修改 loadProjectAndEstimate 函数

**修改前**:
```typescript
const loadProjectAndEstimate = async () => {
  // ... 全部从服务器加载
}
```

**修改后**:
```typescript
const loadProjectAndEstimate = async (useCache: boolean = false) => {
  abortControllerRef.current?.abort()
  abortControllerRef.current = new AbortController()
  
  setLoading(true)
  
  try {
    // 并行加载项目信息和投资估算
    const [projectResponse, estimateResponse] = await Promise.all([
      projectApi.getById(id!),
      investmentApi.getByProjectId(id!, {
        signal: abortControllerRef.current.signal,
        useCache: useCache  // 使用缓存标志
      })
    ])
    
    // ... 处理响应
  } finally {
    setLoading(false)
  }
}
```

#### 3. 修改 API 缓存逻辑

**文件**: `client/src/lib/api.ts`

**修改投资估算 API**:
```typescript
getByProjectId: (projectId: string, options?: { signal?: AbortSignal; useCache?: boolean }) => {
  const cacheKey = `investment:${projectId}`
  
  // 使用缓存时，先检查缓存
  if (options?.useCache !== false) {
    const cachedData = dataCache.get(cacheKey)
    if (cachedData) {
      console.log(`[API] 使用缓存: ${cacheKey}`)
      return Promise.resolve(cachedData)
    }
  }
  
  // 缓存不存在，从服务器获取
  return api.get(`/investment/project/${projectId}`, {
    signal: options?.signal
  }).then(response => {
    // 成功后缓存数据
    if (response.success && response.data?.estimate) {
      dataCache.set(cacheKey, response)
      console.log(`[API] 已缓存: ${cacheKey}`)
    }
    return response
  })
}
```

#### 4. 优化状态更新

移除不必要的 `setTimeout`，直接更新状态：

```typescript
// 修改前
setTimeout(() => setEstimate(estimateData), 0)

// 修改后
setEstimate(estimateData)
```

### 优化效果

| 优化项 | 优化前 | 优化后 |
|--------|--------|--------|
| API 调用次数 | 2-4 次 | 0-1 次 |
| 缓存使用 | 每次都清除 | 优先使用缓存 |
| 并发请求 | 串行加载 | 并行加载 |
| 开发环境 | 2 次调用 | 1 次调用 |

## 实施步骤

1. [ ] 修改 `InvestmentSummary.tsx` 中的 `useEffect` 加载逻辑
2. [ ] 添加加载状态锁 `isLoadingRef`
3. [ ] 修改 `loadProjectAndEstimate` 支持缓存
4. [ ] 修改 `api.ts` 中的 `getByProjectId` 缓存逻辑
5. [ ] 移除不必要的 `setTimeout` 调用
6. [ ] 测试加载流程

## 风险评估

| 风险 | 级别 | 应对措施 |
|------|------|----------|
| 缓存数据过期 | 低 | 添加缓存过期检查（30分钟TTL） |
| 并发请求冲突 | 中 | 使用加载状态锁防止重复 |
| 开发环境调试 | 低 | 保留 `loadCounterRef` 计数器 |

## 验证方法

1. 打开浏览器开发者工具的 Network 面板
2. 从其他页面进入投资估算简表
3. 观察 API 请求次数（应不超过 2 次并行请求）
4. 检查控制台日志确认缓存使用情况
