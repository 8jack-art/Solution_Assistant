# 投资估算简表数据库存储机制设计（迭代优化版）

## 一、核心需求

> "数据变动的时候会保存。但是迭代过程中不保存，迭代完成后会保存一次。"

**关键点**：
- ✅ 数据变动时自动保存（保持用户体验）
- ❌ 迭代计算过程中不写入数据库
- ✅ 迭代完成后只保存最终结果（一次）

---

## 二、设计原理

### 迭代计算过程

```
用户触发计算
    ↓
┌─────────────────────────────────────────────────────────┐
│  迭代计算阶段（内存中执行）                               │
│  - 第1次迭代 → 计算结果1（不保存）                        │
│  - 第2次迭代 → 计算结果2（不保存）                        │
│  - ...                                                   │
│  - 第N次迭代 → 计算结果N（不保存）                        │
│  - 收敛或达到最大次数                                     │
└─────────────────────────────────────────────────────────┘
    ↓
  迭代完成
    ↓
┌─────────────────────────────────────────────────────────┐
│  保存阶段（仅一次）                                       │
│  - 将最终结果保存到数据库                                 │
└─────────────────────────────────────────────────────────┘
    ↓
返回结果给前端
```

### 核心原则

**后端迭代过程在内存中完成，不触及数据库**
**只有整个迭代计算完成后，才进行一次数据库写入**

---

## 三、实现方案

### 3.1 后端实现（投资估算计算器）

**当前问题**：
`calculateInvestmentEstimate` 函数本身是在内存中执行的，不会写入数据库。
问题在于 API 层（`generateSummary`）每次调用后都会保存。

**解决方案**：
在 API 层增加控制：
- 添加 `shouldSave` 参数控制是否保存
- 或者分离"计算"和"保存"逻辑

### 3.2 API设计

#### 方案A：增加保存控制参数（推荐）

```typescript
// 计算并可选择是否保存
POST /api/investment/generate/:projectId

请求体：
{
  ai_items?: InvestmentItem[],
  custom_loan_amount?: number,
  custom_land_cost?: number,
  save_after_complete: boolean  // 迭代完成后是否保存
}
```

**工作流程**：
1. 前端触发计算时，设置 `save_after_complete: true`
2. 后端执行迭代计算（整个过程在内存中）
3. 迭代完成后，检查 `save_after_complete`
4. 如果为 true，仅保存最终结果一次
5. 返回计算结果

#### 方案B：分离计算和保存API

```typescript
// 仅计算
POST /api/investment/calculate
// 返回计算结果，不保存

// 保存结果
POST /api/investment/save
// 由前端调用保存
```

**本次采用方案A**，保持现有API兼容，同时解决迭代保存问题。

---

## 四、详细设计

### 4.1 后端改动

#### 投资估算控制器 (`investmentController.ts`)

```typescript
static async generateSummary(req: AuthRequest, res: Response) {
  try {
    const { projectId } = req.params
    const { 
      ai_items, 
      custom_loan_amount, 
      custom_land_cost,
      save_after_complete = true  // 默认保存
    } = req.body
    
    // ... 权限验证 ...
    
    // 1. 执行迭代计算（整个过程在内存中，不触及数据库）
    const result = calculateInvestmentEstimate({
      projectName: project.project_name,
      targetInvestment: project.total_investment,
      constructionYears: project.construction_years,
      operationYears: project.operation_years,
      loanRatio: custom_loan_amount ? undefined : project.loan_ratio,
      loanInterestRate: project.loan_interest_rate,
      landCost: custom_land_cost ?? project.land_cost ?? 0,
      aiGeneratedItems: ai_items,
      customLoanAmount: custom_loan_amount
    })
    
    // 2. 如果需要保存，仅在迭代完成后保存一次
    if (save_after_complete) {
      const estimateData = {
        project_id: projectId,
        estimate_data: result,
        // ... 其他字段
      }
      
      const existingEstimate = await InvestmentEstimateModel.findByProjectId(projectId)
      
      if (existingEstimate) {
        await InvestmentEstimateModel.update(existingEstimate.id, estimateData)
      } else {
        await InvestmentEstimateModel.create(estimateData)
      }
      
      console.log('[投资估算] 迭代完成，已保存最终结果')
    } else {
      console.log('[投资估算] 迭代完成，未保存（仅计算模式）')
    }
    
    // 3. 返回结果
    res.json({
      success: true,
      data: {
        summary: result,
        saved: save_after_complete  // 告知前端是否已保存
      }
    })
  } catch (error) {
    console.error('生成投资估算简表失败:', error)
    res.status(500).json({ success: false, error: '计算失败' })
  }
}
```

### 4.2 前端改动

#### API层 (`api.ts`)

```typescript
export const investmentApi = {
  // 原有方法保留，向后兼容
  generateSummary: (projectId: string, aiItems?: any[], customLoanAmount?: number, customLandCost?: number) =>
    retryRequest(async () => {
      const response = await api.post<any, ApiResponse<{ summary: any; saved: boolean }>>(
        `/investment/generate/${projectId}`,
        {
          ai_items: aiItems,
          custom_loan_amount: customLoanAmount,
          custom_land_cost: customLandCost,
          save_after_complete: true  // 迭代完成后自动保存
        }
      )
      return response
    }),
  
  // 新增：仅计算模式（不保存）
  calculateOnly: (projectId: string, aiItems?: any[], customLoanAmount?: number, customLandCost?: number) =>
    retryRequest(async () => {
      const response = await api.post<any, ApiResponse<{ summary: any; saved: boolean }>>(
        `/investment/generate/${projectId}`,
        {
          ai_items: aiItems,
          custom_loan_amount: customLoanAmount,
          custom_land_cost: customLandCost,
          save_after_complete: false  // 仅计算，不保存
        }
      )
      return response
    }),
  
  // ... 其他方法
}
```

#### 组件层 (`InvestmentSummary.tsx`)

```typescript
// 通用计算函数（迭代完成后自动保存一次）
const handleCalculate = async () => {
  setGenerating(true)
  try {
    const tableItems = extractCurrentTableItems()
    
    // 调用时 save_after_complete 默认为 true
    const response = await investmentApi.generateSummary(id!, tableItems)
    
    if (response.success && response.data) {
      setEstimate(response.data.summary)
      
      if (response.data.saved) {
        notifications.show({
          title: '✅ 计算完成',
          message: '投资估算已自动保存',
          color: 'green',
          autoClose: 3000
        })
      }
    }
  } catch (error) {
    // 错误处理
  } finally {
    setGenerating(false)
  }
}

// 手动保存（用户确认后）
const handleManualSave = async () => {
  if (!estimate) return
  
  try {
    const response = await investmentApi.save({
      project_id: id!,
      estimate_data: estimate
    })
    
    if (response.success) {
      notifications.show({
        title: '✅ 保存成功',
        message: '投资估算已保存',
        color: 'green'
      })
    }
  } catch (error) {
    notifications.show({
      title: '❌ 保存失败',
      message: '请稍后重试',
      color: 'red'
    })
  }
}
```

---

## 五、流程图

### 5.1 前端触发计算

```
用户操作（修改子项/点击生成等）
    ↓
调用 investmentApi.generateSummary(..., save_after_complete: true)
    ↓
后端：执行迭代计算（内存中）
    ↓
┌─────────────────────────────────────┐
│ 迭代过程（不接触数据库）             │
│ - 迭代1 → 结果1                     │
│ - 迭代2 → 结果2                     │
│ - ...                               │
│ - 收敛或达到上限                    │
└─────────────────────────────────────┘
    ↓
迭代完成
    ↓
保存最终结果到数据库（仅一次）
    ↓
返回结果给前端
    ↓
前端显示结果 + "已保存"提示
```

### 5.2 迭代过程中的数据流

```
┌─────────────────────────────────────────────────────────────────┐
│                     后端进程                                     │
│                                                                 │
│  calculateInvestmentEstimate()                                  │
│  ┌─────────────────────────────────────────────────────────┐   │
│  │ for interestIter = 0 to MAX_ITERATIONS                  │   │
│  │   计算建设期利息                                         │   │
│  │   计算建设单位管理费                                     │   │
│  │   收敛检查                                               │   │
│  │   ← 不写入数据库，全程内存操作                           │   │
│  └─────────────────────────────────────────────────────────┘   │
│                          ↓                                      │
│  迭代完成                                                       │
│                          ↓                                      │
│  ┌─────────────────────────────────────────────────────────┐   │
│  │ if (save_after_complete) {                              │   │
│  │   InvestmentEstimateModel.save(...)  ← 仅此处写入DB    │   │
│  │ }                                                        │   │
│  └─────────────────────────────────────────────────────────┘   │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

---

## 六、优势

### 6.1 性能优化

| 场景 | 优化前 | 优化后 |
|------|--------|--------|
| 10次迭代 | 10次数据库写入 | 1次数据库写入 |
| 频繁修改子项 | 每次都保存 | 仅最终结果保存 |

### 6.2 用户体验

- ✅ 数据变动时自动保存（用户无感知）
- ✅ 迭代过程中不卡顿（无数据库IO）
- ✅ 迭代完成后立即保存（数据不丢失）

### 6.3 数据一致性

- 只保存最终收敛结果，避免中间状态污染数据库
- 即使迭代失败，也不会保存不完整数据

---

## 七、代码改动清单

### 后端
- [ ] `server/src/controllers/investmentController.ts`
  - `generateSummary` 方法增加 `save_after_complete` 参数
  - 迭代完成后统一保存逻辑

### 前端
- [ ] `client/src/lib/api.ts`
  - `generateSummary` 默认设置 `save_after_complete: true`
  - 可选新增 `calculateOnly` 方法

### 数据库
- 无需改动（保持现有结构）

---

## 八、总结

**核心改动**：
1. 后端 `generateSummary` API 增加 `save_after_complete` 参数
2. 迭代计算过程完全在内存中进行，不触及数据库
3. 只有迭代完成（收敛或达到上限）后，才进行一次数据库写入

**收益**：
- 性能提升：减少90%的数据库写入
- 用户体验：迭代过程更流畅
- 数据质量：只保存最终收敛结果
