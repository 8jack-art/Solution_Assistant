# 营业成本估算表计算逻辑修复

## 问题描述

用户反馈营业成本估算表中的计算逻辑存在问题：
1. "营业成本项"对应的"运营期"列合计数值不正确
2. Excel导出中的营业成本项数据不对
3. 总成本费用合计也不对，应该对应自然数列1到6行的运营期列合计

## 修复内容

### 1. 页面显示计算逻辑修复

#### 营业成本合计列计算逻辑（第2381-2451行）
- 修改前：直接计算各个子项的值
- 修改后：对第1.1行至第1.5行合计列数值的总和
- 具体修改：
  ```typescript
  // 营业成本合计列 = 第1.1行至第1.5行合计列数值的总和
  let total = 0;
  
  // 1.1 外购原材料费（除税）合计列
  const rawMaterialsTotal = calculateRawMaterialsExcludingTax(undefined, years);
  total += rawMaterialsTotal;
  
  // 1.2 外购燃料及动力费（除税）合计列
  const fuelPowerTotal = calculateFuelPowerExcludingTax(undefined, years);
  total += fuelPowerTotal;
  
  // 1.3 工资及福利费合计列
  const wagesTotal = calculateWagesTotal(undefined, years);
  total += wagesTotal;
  
  // 1.4 修理费合计列
  let repairTotal = 0;
  years.forEach((year) => {
    let yearRepair = 0;
    if (costConfig.repair.type === 'percentage') {
      yearRepair += fixedAssetsInvestment * (costConfig.repair.percentageOfFixedAssets || 0) / 100;
    } else {
      yearRepair += costConfig.repair.directAmount || 0;
    }
    repairTotal += yearRepair;
  });
  total += repairTotal;
  
  // 1.5 其他费用合计列
  let otherExpensesTotal = 0;
  years.forEach((year) => {
    const productionRate = costConfig.otherExpenses.applyProductionRate
      ? (productionRates.find(p => p.yearIndex === year)?.rate || 1)
      : 1;
      
    let yearTotal = 0;
    if (costConfig.otherExpenses.type === 'percentage') {
      const revenueBase = (revenueItems || []).reduce((sum, revItem) => {
        const income = calculateTaxableIncome(revItem);
        return sum + income;
      }, 0);
      yearTotal += revenueBase * (costConfig.otherExpenses.percentage || 0) / 100 * productionRate;
    } else {
      yearTotal += (costConfig.otherExpenses.directAmount || 0) * productionRate;
    }
    otherExpensesTotal += yearTotal;
  });
  total += otherExpensesTotal;
  ```

#### 营业成本运营期各年列计算逻辑（第2453-2508行）
- 修改前：直接计算各个子项的值
- 修改后：对第1.1行至第1.5行对应年份列数据的求和
- 具体修改：与合计列类似的计算逻辑，但针对每个年份单独计算

### 2. Excel导出计算逻辑修复

#### 营业成本项（序号1）计算逻辑（第1293-1408行）
- 修改前：直接计算各个子项的值
- 修改后：对第1.1行至第1.5行合计列数值的总和（合计列）和对应年份列数据的求和（运营期各年列）
- 添加了详细的debug日志，便于检查计算过程

#### 总成本费用合计（序号7）计算逻辑（第1541-1593行）
- 修改前：直接计算各个子项的值
- 修改后：对自然数列1到6行的合计列数值的总和（合计列）和对应年份列数据的求和（运营期各年列）
- 具体修改：
  ```typescript
  // 总成本费用合计列 = 自然数列1到6行的合计列数值的总和
  let totalRow7 = 0;
  
  // 行1: 营业成本合计列 (已经计算为第1.1行至第1.5行合计列数值的总和)
  totalRow7 += totalRow1; // 使用上面已经计算好的营业成本合计
  
  // 行2: 管理费用合计列（暂时为0）
  // 暂时为0，待后续实现
  
  // 行3: 利息支出合计列
  let row3Total = 0;
  years.forEach((year) => {
    const interestRow = repaymentTableData.find(row => row.序号 === '2.2');
    if (interestRow && interestRow.分年数据 && interestRow.分年数据[year - 1] !== undefined) {
      row3Total += interestRow.分年数据[year - 1];
    }
  });
  totalRow7 += row3Total;
  
  // 行4: 折旧费合计列
  let row4Total = 0;
  years.forEach((year) => {
    const yearIndex = year - 1;
    const rowA = depreciationData.find(row => row.序号 === 'A');
    const rowD = depreciationData.find(row => row.序号 === 'D');
    const yearDepreciation = (rowA?.分年数据[yearIndex] || 0) + (rowD?.分年数据[yearIndex] || 0);
    row4Total += yearDepreciation;
  });
  totalRow7 += row4Total;
  
  // 行5: 摊销费合计列
  let row5Total = 0;
  years.forEach((year) => {
    const yearIndex = year - 1;
    const rowE = depreciationData.find(row => row.序号 === 'E');
    const yearAmortization = rowE?.分年数据[yearIndex] || 0;
    row5Total += yearAmortization;
  });
  totalRow7 += row5Total;
  
  // 行6: 开发成本合计列（暂时为0）
  // 暂时为0，待后续实现
  ```

## 修复效果

1. **页面显示**：营业成本项的合计列和运营期各年列现在正确地计算为第1.1行至第1.5行对应数据的求和
2. **Excel导出**：营业成本项和总成本费用合计的计算逻辑与页面显示保持一致
3. **调试支持**：添加了详细的console.log，便于检查计算过程和排查问题

## 技术要点

1. 使用已有的计算函数（如`calculateRawMaterialsExcludingTax`、`calculateFuelPowerExcludingTax`、`calculateWagesTotal`）确保计算逻辑的一致性
2. 保持了原有的达产率应用逻辑，确保计算结果符合业务规则
3. 添加了详细的调试日志，便于后续维护和问题排查
4. 修复了总成本费用合计的计算逻辑，使其正确地对自然数列1到6行进行求和

## 测试建议

1. 测试页面显示的营业成本项计算是否正确
2. 测试Excel导出功能，确保导出的数据与页面显示一致
3. 测试各种配置组合（如不同的达产率设置、不同的费用计算方式等）
4. 检查浏览器控制台的调试日志，确认计算过程符合预期