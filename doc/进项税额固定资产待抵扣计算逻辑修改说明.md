# 进项税额（固定资产待抵扣）计算逻辑修改说明

## 修改日期
2026年1月20日

## 修改内容
修改了`DynamicRevenueTable.tsx`文件中的`calculateFixedAssetInputTaxForYear`函数，优化了进项税额（固定资产待抵扣）的计算逻辑。

## 修改背景
用户反馈：当运营期列的"销项税额"减"进项税额"值小于0时，需要特殊处理进项税额（固定资产待抵扣）的计算，确保当年的增值税为0。

## 新的计算逻辑

### 核心规则
1. **当销项税额 - 进项税额 > 0 时**：使用需要的值与剩余待抵扣税的较小值
2. **当销项税额 - 进项税额 ≤ 0 时**：
   - 当年的"进项税额（固定资产待抵扣）"设为0，确保增值税为0
   - 取其绝对值B1，累加到待抵扣进项税中，留待后续年度使用

### 具体实现
```typescript
const calculateFixedAssetInputTaxForYear = (year: number): number => {
  if (!context) return 0;
  
  const operationYears = context.operationYears;
  const years = Array.from({ length: operationYears }, (_, i) => i + 1);
  
  // 计算每年的销项税额和进项税额
  const yearlyData = years.map((y) => {
    // 计算销项税额
    const yearOutputTax = revenueItems.reduce((sum, item) => {
      const productionRate = getProductionRateForYear(useRevenueCostStore.getState().productionRates, y)
      const revenue = calculateYearlyRevenue(item, y, productionRate)
      // 销项税额 = 含税收入 - 不含税收入
      return sum + (revenue - revenue / (1 + item.vatRate))
    }, 0);
    
    // 计算进项税额
    const yearInputTax = calculateTotalInputTaxForYear(y);
    
    return {
      year: y,
      outputTax: yearOutputTax,
      inputTax: yearInputTax
    };
  });
  
  // 计算每年的进项税额（固定资产待抵扣）
  let remainingDeductibleTax = deductibleInputTax;
  const fixedAssetInputTaxes: number[] = [];
  
  for (const data of yearlyData) {
    // 计算销项税额 - 进项税额的值
    const netTaxDifference = data.outputTax - data.inputTax;
    
    // 当运营期列的"销项税额"减"进项税额"值大于0时，使用需要的值
    let actualFixedAssetInputTax = 0;
    if (netTaxDifference > 0 && remainingDeductibleTax > 0) {
      // 如果还有剩余的待抵扣进项税，则使用需要的值，否则使用剩余值
      actualFixedAssetInputTax = Math.min(netTaxDifference, remainingDeductibleTax);
    } else if (netTaxDifference <= 0) {
      // 当"销项税额"减"进项税额"值小于等于0时，
      // 取其绝对值B1，累加到待抵扣进项税中（形成新的待抵扣进项税A1 = A + B1）
      // 当年的进项税额（固定资产待抵扣）仍为0，确保增值税为0
      const b1 = Math.abs(netTaxDifference);
      remainingDeductibleTax += b1;
      actualFixedAssetInputTax = 0;
    }
    
    fixedAssetInputTaxes.push(actualFixedAssetInputTax);
    remainingDeductibleTax -= actualFixedAssetInputTax;
  }
  
  // 返回指定年份的进项税额（固定资产待抵扣）
  return fixedAssetInputTaxes[year - 1] || 0;
};
```

## 逻辑说明

### 场景1：`销项税额 - 进项税额 > 0`
- 计算公式：`actualFixedAssetInputTax = Math.min(netTaxDifference, remainingDeductibleTax)`
- 含义：取需要的进项税额（固定资产待抵扣）与剩余待抵扣税的较小值
- 目的：确保增值税恰好为0，充分利用待抵扣进项税

### 场景2：`销项税额 - 进项税额 ≤ 0`
- 计算公式：
  - `remainingDeductibleTax += Math.abs(netTaxDifference)` - 将负值绝对值累加到待抵扣进项税
  - `actualFixedAssetInputTax = 0` - 当年的进项税额（固定资产待抵扣）为0
- 含义：
  1. 当销项税不足以抵扣进项税时，不进行固定资产进项税抵扣
  2. 将差值的绝对值（B1）累加到待抵扣进项税中，留待后续年度使用
  3. 当年增值税 = 0（因为没有使用任何固定资产进项税抵扣）
- 目的：确保当年的增值税为0，同时保留待抵扣进项税供后续年度使用

## 计算示例

假设某项目运营期3年，待抵扣进项税初始值为100：

| 年份 | 销项税额 | 进项税额 | 销项-进项 | 处理方式 | 本年抵扣 | 剩余待抵扣 |
|------|----------|----------|-----------|----------|----------|------------|
| 1    | 50       | 80       | -30       | 累加B1=30 | 0        | 130        |
| 2    | 100      | 60       | +40       | 使用抵扣  | 40       | 90         |
| 3    | 80       | 50       | +30       | 使用抵扣  | 30       | 60         |

第1年增值税 = 50 - 80 - 0 = 0（符合要求）
第2年增值税 = 100 - 60 - 40 = 0（符合要求）
第3年增值税 = 80 - 50 - 30 = 0（符合要求）

## 影响范围
- 营业收入、营业税金及附加和增值税估算表modal中的2.3行数据
- Excel导出功能中的2.3行数据
- 所有依赖于该函数计算的增值税相关数据

## 测试建议
1. 测试场景：销项税额 - 进项税额 > 0 的年份
2. 测试场景：销项税额 - 进项税额 < 0 的年份
3. 测试场景：连续多年不同情况的组合
4. 验证Excel导出功能
5. 验证增值税计算的准确性（确保每年增值税都为0）

## 相关文件
- `client/src/components/revenue-cost/DynamicRevenueTable.tsx`
  - `calculateFixedAssetInputTaxForYear` 函数（第720-777行）
  - `calculateVatForYear` 函数（第694-714行）
