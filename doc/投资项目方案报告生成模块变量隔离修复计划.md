# 投资项目方案报告生成模块变量隔离修复计划

## 问题概述

投资项目方案报告生成模块中的可用变量没有做项目隔离，导致A项目的变量数据（如`{{DATA:investment_estimate}}`）串到了B项目中，造成报告生成时使用了错误的项目数据。

**重要约束**：变量名不能改变，因为已经嵌入到LLM的提示词模板中了。

## 问题根本原因分析

### 1. 前端变量缓存问题

在`client/src/stores/reportStore.ts`中，`cachedTableDataJSON`是全局状态，没有按项目ID隔离：

```typescript
// 当前代码中的问题
cachedTableDataJSON: Record<string, string>  // 缓存的表格数据JSON（用于LLM提示词）
```

当用户从A项目切换到B项目时，`cachedTableDataJSON`可能保留A项目的数据，导致B项目使用了A项目的变量值。

### 2. 后端数据获取问题

在`server/src/controllers/reportController.ts`的`getProjectSummary`函数中，表格数据是实时构建的，但`tableDataJSON`可能包含旧项目的数据。

### 3. 报告服务中的变量替换问题

在`server/src/services/reportService.ts`中，变量替换逻辑直接使用传入的`tableDataJSON`，没有验证这些数据是否属于当前请求的项目。

## 解决方案设计（不改变变量名）

### 1. 前端变量缓存隔离

**目标**：确保每个项目的变量数据独立存储在缓存中，避免项目间数据串用。

**实现方案**：

修改`reportStore.ts`中的`cachedTableDataJSON`结构，从全局缓存改为按项目ID隔离的缓存：

```typescript
// 修改后的结构
cachedTableDataJSON: Record<string, Record<string, string>>  // 按项目ID隔离的缓存
// 格式：{ [projectId]: { [variableKey]: variableValue } }
```

**关键修改**：

1. 修改`loadProjectData`函数：
```typescript
loadProjectData: async () => {
  const { projectId } = get()
  // ... 获取数据 ...
  
  // 按项目ID隔离缓存
  set((state) => ({
    cachedTableDataJSON: {
      ...state.cachedTableDataJSON,
      [projectId]: tableDataJSON  // 只缓存当前项目的数据
    }
  }))
}
```

2. 修改`setProjectId`函数，切换项目时清理缓存：
```typescript
setProjectId: (id) => {
  set({ 
    projectId: id,
    // 切换项目时只保留当前项目的缓存
    cachedTableDataJSON: { [id]: get().cachedTableDataJSON[id] }
  })
}
```

3. 修改`startGeneration`函数，确保传递当前项目的缓存数据：
```typescript
startGeneration: async () => {
  const { projectId, cachedTableDataJSON } = get()
  // 使用当前项目的缓存数据
  const tableDataJSON = cachedTableDataJSON[projectId] || {}
  // ...
}
```

### 2. 后端数据获取隔离

**目标**：确保每次请求都获取正确的项目数据，不依赖可能过时的缓存。

**实现方案**：

修改`reportController.ts`的`getProjectSummary`函数：

```typescript
static async getProjectSummary(req: Request, res: Response): Promise<void> {
  const { projectId } = req.params
  const userId = ReportController.getUserId(req)
  
  // 验证项目归属
  const [projects] = await pool.execute(
    'SELECT * FROM investment_projects WHERE id = ? AND user_id = ?',
    [projectId, userId]
  ) as any[]
  
  // 收集项目数据（每次请求都实时获取）
  const projectData = await ReportService.collectProjectData(projectId)
  
  // 构建所有表格数据的JSON
  const tableDataJSON = buildAllTableDataJSON(projectData)
  
  // 返回当前项目的数据
  res.json({
    success: true,
    data: {
      // ... 项目基本信息
      tableDataJSON  // 只包含当前项目的数据
    }
  })
}
```

### 3. 后端变量替换隔离

**目标**：在变量替换时，确保使用的数据属于当前请求的项目。

**实现方案**：

修改`reportService.ts`中的`generateReportStream`函数：

```typescript
static async generateReportStream(
  reportId: string,
  llmConfig: any,
  promptTemplate: string,
  project: any,
  tableDataJSON?: Record<string, string>
): Promise<void> {
  // 收集当前项目的数据
  const projectData = await this.collectProjectData(project.id)
  
  // 如果前端传入了tableDataJSON，使用后端实时构建的数据替换
  // 这样可以确保使用的是当前项目的数据
  if (tableDataJSON) {
    console.log('使用后端实时构建的数据替换前端传入的tableDataJSON')
    projectData.tableDataJSON = buildAllTableDataJSON(projectData)
  }
  
  // 构建完整的提示词
  const fullPrompt = this.buildDataAwarePrompt(promptTemplate, projectData)
  // ...
}
```

### 4. 后端表格数据构建隔离

**目标**：确保表格数据构建时只使用当前项目的数据。

**实现方案**：

修改`buildAllTableDataJSON`函数，在构建数据时使用项目ID作为日志标识：

```typescript
export function buildAllTableDataJSON(projectData: any, projectId?: string): Record<string, string> {
  const jsonData: Record<string, string> = {}
  const logPrefix = projectId ? `[项目 ${projectId}]` : ''
  
  console.log(`${logPrefix} 开始构建表格数据JSON`)
  
  // 构建表格数据
  jsonData['DATA:investment_estimate'] = buildInvestmentEstimateJSON(projectData.investment)
  jsonData['DATA:depreciation_amortization'] = buildDepreciationAmortizationJSON(...)
  // ... 其他表格数据
  
  console.log(`${logPrefix} 表格数据JSON构建完成，keys: ${Object.keys(jsonData).join(', ')}`)
  
  return jsonData
}
```

## 实施步骤

### 步骤1：修改前端报告存储（主要修复）

1. 修改`client/src/stores/reportStore.ts`中的`ReportState`接口，更新`cachedTableDataJSON`类型
2. 修改`loadProjectData`函数，实现按项目ID隔离的缓存机制
3. 修改`setProjectId`函数，添加缓存清理逻辑
4. 修改`startGeneration`函数，确保传递当前项目的缓存数据
5. 修改`resetReport`函数，清理所有项目缓存

### 步骤2：修改后端报告控制器（辅助修复）

1. 修改`server/src/controllers/reportController.ts`中的`getProjectSummary`函数
2. 确保每次请求都实时获取项目数据
3. 添加数据验证日志

### 步骤3：修改后端报告服务（辅助修复）

1. 修改`server/src/services/reportService.ts`中的`generateReportStream`函数
2. 始终使用后端实时构建的数据，不依赖前端缓存
3. 添加数据验证日志

### 步骤4：修改后端表格数据构建器（辅助修复）

1. 修改`server/src/utils/tableDataBuilder.ts`中的`buildAllTableDataJSON`函数
2. 添加项目ID作为日志标识
3. 增强日志输出，便于问题排查

### 步骤5：测试验证

1. 创建测试用例，验证变量隔离功能
2. 测试项目切换场景，确保缓存正确清理
3. 测试报告生成，验证使用正确的项目数据
4. 测试报告列表，确保每个报告关联正确的数据

## 向后兼容性

本方案完全保持变量名不变，不影响现有的提示词模板。

## 预期效果

1. 每个项目的变量数据在缓存中完全独立，不会相互影响
2. 项目切换时自动清理非当前项目的缓存数据
3. 报告生成时使用正确的项目数据
4. 完全保持向后兼容性，不影响现有功能