# 预览样式应用重写实施计划

## 概述
本计划详细说明如何重写预览样式设置应用到预览区的代码，解决行间距和段落缩进不生效的问题。

## 实施步骤

### 第一步：创建样式计算工具函数

**文件**：`client/src/utils/styleCalculator.ts`

**内容**：实现样式计算工具函数，包括：
- `calculateLineHeight` - 计算行高，支持倍数行距和固定行距
- `calculateTextIndent` - 计算段落缩进，基于字符宽度的相对计算
- `calculateParagraphSpacing` - 计算段落间距
- `calculateParagraphStyle` - 计算完整的段落样式
- `getComputedParagraphStyle` - 从样式配置中提取并计算段落样式
- `getTableStyles` - 计算表格样式
- `createStyleCacheKey` - 创建样式缓存键

### 第二步：重写 replaceVariablesInContent 函数

**文件**：`client/src/components/report/ReportPreview.tsx`

**修改内容**：
1. 修改函数签名，添加 tableStyles 参数
2. 使用计算后的表格样式替换硬编码样式
3. 添加 styleToString 工具函数，将样式对象转换为 CSS 字符串

### 第三步：重写 MarkdownRenderer 组件

**文件**：`client/src/components/report/ReportPreview.tsx`

**修改内容**：
1. 导入样式计算工具函数
2. 使用 useMemo 缓存样式计算结果
3. 使用计算后的样式配置 ReactMarkdown 组件
4. 优化渲染性能

### 第四步：更新 ReportPreview 主组件

**文件**：`client/src/components/report/ReportPreview.tsx`

**修改内容**：
1. 确保样式配置正确传递给 MarkdownRenderer
2. 优化样式配置的合并逻辑
3. 添加样式变化监听

## 详细代码实现

### 1. 样式计算工具函数

```typescript
// client/src/utils/styleCalculator.ts
import type { ReportStyleConfig, ParagraphStyle } from '../types/report'

// 计算行高
export const calculateLineHeight = (
  lineSpacing: number | 'fixed',
  fontSize: number,
  lineSpacingValue?: number
): string => {
  if (lineSpacing === 'fixed' && lineSpacingValue) {
    return `${lineSpacingValue}px`
  }
  return lineSpacing.toString()
}

// 计算段落缩进
export const calculateTextIndent = (
  indentChars: number,
  fontSize: number
): string => {
  if (indentChars <= 0) {
    return '0'
  }
  return `${indentChars}em`
}

// 计算段落间距
export const calculateParagraphSpacing = (
  spacingValue: number,
  fontSize: number,
  lineHeight: number | string
): string => {
  if (spacingValue <= 0) {
    return '0'
  }
  
  const singleLineHeight = typeof lineHeight === 'number' 
    ? fontSize * lineHeight 
    : parseFloat(lineHeight) * fontSize
  
  return `${spacingValue * singleLineHeight}px`
}

// 计算完整的段落样式
export const calculateParagraphStyle = (
  style: ParagraphStyle,
  baseFontSize: number = 12
): React.CSSProperties => {
  const {
    font,
    fontSize,
    bold,
    lineSpacing,
    lineSpacingValue,
    spaceBefore,
    spaceAfter,
    firstLineIndent
  } = style

  const lineHeight = calculateLineHeight(
    lineSpacing,
    fontSize,
    lineSpacingValue
  )

  const textIndent = calculateTextIndent(firstLineIndent, fontSize)
  
  const marginTop = calculateParagraphSpacing(spaceBefore, fontSize, lineHeight)
  const marginBottom = calculateParagraphSpacing(spaceAfter, fontSize, lineHeight)

  return {
    fontFamily: font,
    fontSize: `${fontSize}px`,
    fontWeight: bold ? 'bold' : 'normal',
    lineHeight,
    textIndent,
    marginTop,
    marginBottom
  }
}

// 从样式配置中提取并计算段落样式
export const getComputedParagraphStyle = (
  config: ReportStyleConfig,
  type: 'heading1' | 'heading2' | 'heading3' | 'body'
): React.CSSProperties => {
  // 优先使用独立样式配置
  const paragraphStyle = config[type]
  if (paragraphStyle) {
    return calculateParagraphStyle(paragraphStyle)
  }

  // 向后兼容：使用旧配置
  const fallbackStyle: ParagraphStyle = {
    font: config.fonts?.body || '宋体',
    fontSize: config.fontSizes?.body || 12,
    bold: false,
    lineSpacing: config.paragraph?.lineSpacing || 1.5,
    lineSpacingValue: config.paragraph?.lineSpacingValue,
    spaceBefore: config.paragraph?.spaceBefore || 0,
    spaceAfter: config.paragraph?.spaceAfter || 0,
    firstLineIndent: config.paragraph?.firstLineIndent || 2
  }

  // 标题样式特殊处理
  if (type === 'heading1') {
    fallbackStyle.font = config.fonts?.heading || '黑体'
    fallbackStyle.fontSize = config.fontSizes?.title || 22
    fallbackStyle.bold = true
    fallbackStyle.firstLineIndent = config.paragraph?.headingIndent || 0
  } else if (type === 'heading2') {
    fallbackStyle.font = config.fonts?.heading || '黑体'
    fallbackStyle.fontSize = 16
    fallbackStyle.bold = true
    fallbackStyle.firstLineIndent = config.paragraph?.headingIndent || 0
  } else if (type === 'heading3') {
    fallbackStyle.font = config.fonts?.heading || '黑体'
    fallbackStyle.fontSize = 15
    fallbackStyle.bold = true
    fallbackStyle.firstLineIndent = config.paragraph?.headingIndent || 0
  }

  return calculateParagraphStyle(fallbackStyle)
}

// 计算表格样式
export const getTableStyles = (config: ReportStyleConfig) => {
  const {
    fonts,
    fontSizes,
    table
  } = config

  return {
    table: {
      borderCollapse: 'collapse' as const,
      width: '100%',
      margin: '8px 0',
      fontSize: `${fontSizes?.tableBody || 12}px`,
      fontFamily: fonts?.body || '宋体'
    },
    header: {
      backgroundColor: table?.headerBg ? `#${table.headerBg}` : '#EEEEEE',
      fontWeight: 'bold' as const,
      textAlign: 'center' as const,
      padding: '8px',
      border: '1px solid #000',
      fontFamily: fonts?.body || '宋体',
      fontSize: `${fontSizes?.tableHeader || 12}px`
    },
    cell: {
      padding: '8px',
      border: '1px solid #000',
      textAlign: table?.alignment || 'left' as const,
      fontFamily: fonts?.body || '宋体',
      fontSize: `${fontSizes?.tableBody || 12}px`
    },
    title: {
      fontWeight: 'bold' as const,
      fontFamily: fonts?.body || '宋体',
      fontSize: `${fontSizes?.tableTitle || 18}px`,
      marginBottom: '8px',
      marginTop: '16px'
    }
  }
}

// 创建样式缓存键
export const createStyleCacheKey = (config: ReportStyleConfig): string => {
  return JSON.stringify({
    fonts: config.fonts,
    fontSizes: config.fontSizes,
    paragraph: config.paragraph,
    heading1: config.heading1,
    heading2: config.heading2,
    heading3: config.heading3,
    body: config.body,
    table: config.table
  })
}
```

### 2. 样式对象转字符串工具

```typescript
// 在 ReportPreview.tsx 中添加
const styleToString = (style: React.CSSProperties): string => {
  return Object.entries(style)
    .map(([key, value]) => {
      const cssKey = key.replace(/([A-Z])/g, '-$1').toLowerCase()
      return `${cssKey}: ${value}`
    })
    .join('; ')
}
```

### 3. 重写后的 MarkdownRenderer 组件

```typescript
function MarkdownRenderer({ content, config, resources }: MarkdownRendererProps) {
  // 缓存样式计算结果
  const computedStyles = useMemo(() => {
    return {
      heading1: getComputedParagraphStyle(config, 'heading1'),
      heading2: getComputedParagraphStyle(config, 'heading2'),
      heading3: getComputedParagraphStyle(config, 'heading3'),
      body: getComputedParagraphStyle(config, 'body'),
      table: getTableStyles(config)
    }
  }, [config])
  
  // 缓存变量替换结果
  const contentWithVars = useMemo(() => {
    return replaceVariablesInContent(content, resources, config, computedStyles.table)
  }, [content, resources, config, computedStyles.table])
  
  // 分离 Markdown 内容和已替换的 HTML 内容
  const parts = contentWithVars.split(/(<table[\s\S]*?<\/table>|<div[\s\S]*?<\/div>|<pre[\s\S]*?<\/pre>|<p>.*?<\/p>)/gi)
  
  return (
    <div className="report-content">
      {parts.map((part, index) => {
        // 如果是 HTML 标签包裹的内容，直接渲染
        if (part.startsWith('<table') || part.startsWith('<div') || part.startsWith('<pre') || part.startsWith('<p')) {
          return (
            <div 
              key={index} 
              dangerouslySetInnerHTML={{ __html: part }}
              style={{ margin: '8px 0' }}
            />
          )
        }
        // 否则是 Markdown 内容，使用 ReactMarkdown 渲染
        if (part.trim()) {
          return (
            <ReactMarkdown
              key={index}
              remarkPlugins={[remarkGfm]}
              components={{
                h1: ({ children }) => (
                  <h1 style={computedStyles.heading1}>
                    {children}
                  </h1>
                ),
                h2: ({ children }) => (
                  <h2 style={computedStyles.heading2}>
                    {children}
                  </h2>
                ),
                h3: ({ children }) => (
                  <h3 style={computedStyles.heading3}>
                    {children}
                  </h3>
                ),
                h4: ({ children }) => (
                  <h4 style={{
                    fontFamily: config.fonts?.heading || '黑体',
                    fontWeight: 'bold'
                  }}>
                    {children}
                  </h4>
                ),
                p: ({ children }) => (
                  <p style={computedStyles.body}>
                    {children}
                  </p>
                ),
                ul: ({ children }) => (
                  <ul style={{
                    margin: '8px 0',
                    paddingLeft: '24px'
                  }}>
                    {children}
                  </ul>
                ),
                ol: ({ children }) => (
                  <ol style={{
                    margin: '8px 0',
                    paddingLeft: '24px'
                  }}>
                    {children}
                  </ol>
                ),
                li: ({ children }) => (
                  <li style={{
                    margin: '4px 0',
                    lineHeight: computedStyles.body.lineHeight
                  }}>
                    {children}
                  </li>
                ),
                strong: ({ children }) => (
                  <strong style={{ fontWeight: 'bold' }}>
                    {children}
                  </strong>
                ),
                em: ({ children }) => (
                  <em style={{ fontStyle: 'italic' }}>
                    {children}
                  </em>
                ),
                blockquote: ({ children }) => (
                  <blockquote style={{
                    borderLeft: '4px solid #1890ff',
                    margin: '12px 0',
                    padding: '8px 16px',
                    backgroundColor: '#f5f5f5',
                    color: '#666'
                  }}>
                    {children}
                  </blockquote>
                ),
                code: ({ className, children }) => {
                  const isInline = !className
                  if (isInline) {
                    return (
                      <code style={{
                        fontFamily: 'Consolas, Monaco, monospace',
                        backgroundColor: '#f5f5f5',
                        padding: '2px 6px',
                        borderRadius: '3px',
                        fontSize: '0.9em'
                      }}>
                        {children}
                      </code>
                    )
                  }
                  return (
                    <code className={className}>
                      {children}
                    </code>
                  )
                },
                pre: ({ children }) => (
                  <pre style={{
                    backgroundColor: '#f5f5f5',
                    padding: '12px',
                    borderRadius: '4px',
                    overflowX: 'auto',
                    margin: '12px 0'
                  }}>
                    {children}
                  </pre>
                ),
                hr: () => (
                  <hr style={{
                    border: 'none',
                    borderTop: '1px solid #e8e8e8',
                    margin: '16px 0'
                  }} />
                ),
                // 表格样式
                table: ({ children }) => (
                  <table style={computedStyles.table.table}>
                    {children}
                  </table>
                ),
                thead: ({ children }) => (
                  <thead>
                    {children}
                  </thead>
                ),
                tbody: ({ children }) => (
                  <tbody>
                    {children}
                  </tbody>
                ),
                tr: ({ children }) => (
                  <tr style={{
                    backgroundColor: 'transparent'
                  }}>
                    {children}
                  </tr>
                ),
                th: ({ children }) => (
                  <th style={computedStyles.table.header}>
                    {children}
                  </th>
                ),
                td: ({ children }) => (
                  <td style={computedStyles.table.cell}>
                    {children}
                  </td>
                )
              }}
            >
              {part}
            </ReactMarkdown>
          )
        }
        return null
      })}
    </div>
  )
}
```

### 4. 重写后的 replaceVariablesInContent 函数

```typescript
const replaceVariablesInContent = (
  content: string, 
  resources: ResourceMap, 
  config: ReportStyleConfig,
  tableStyles: ReturnType<typeof getTableStyles>
): string => {
  if (!content) return ''

  let result = content

  // 替换表格数据变量 {{DATA:tableId}} - JSON格式数据
  result = result.replace(/\{\{DATA:(\w+)\}\}/g, (match, dataId) => {
    const tableResource = resources.tables?.[dataId]
    if (tableResource && tableResource.data) {
      const jsonStr = JSON.stringify(tableResource.data, null, 2)
      return `<pre style="background-color: #f5f5f5; padding: 12px; border-radius: 4px; overflow-x: auto; font-size: 12px;">${jsonStr}</pre>`
    }
    return `[表格数据 ${dataId} 未找到]`
  })

  // 替换表格变量 {{TABLE:tableId}}
  result = result.replace(/\{\{TABLE:(\w+)\}\}/g, (match, tableId) => {
    const tableResource = resources.tables?.[tableId]
    if (tableResource) {
      const columns = tableResource.columns || []
      const data = tableResource.data
      const zebraStripe = config.table?.zebraStripe

      const headerRow = columns.map((col: string) => 
        `<th style="${styleToString(tableStyles.header)}">${col}</th>`
      ).join('')

      const dataRows = data.map((row: any, rowIndex: number) => {
        const rowBg = zebraStripe && rowIndex % 2 === 1 ? 'background-color: #F5F5F5;' : ''
        const cells = columns.map((col: string) => 
          `<td style="${styleToString(tableStyles.cell)} ${rowBg}">${row[col] ?? ''}</td>`
        ).join('')
        return `<tr>${cells}</tr>`
      }).join('')

      return `
        <p style="${styleToString(tableStyles.title)}">${tableResource.title || '表格'}</p>
        <table style="${styleToString(tableStyles.table)}">
          <thead><tr>${headerRow}</tr></thead>
          <tbody>${dataRows}</tbody>
        </table>
      `
    }
    return `[表格 ${tableId} 未找到]`
  })

  // 替换图表变量 {{CHART:chartId}}
  result = result.replace(/\{\{CHART:(\w+)\}\}/g, (match, chartId) => {
    const chartResource = resources.charts?.[chartId]
    if (chartResource && chartResource.base64Image) {
      return `
        <p style="${styleToString(tableStyles.title)}">${chartResource.title || '图表'}</p>
        <div style="text-align: center; margin: 16px 0;">
          <img src="${chartResource.base64Image}" alt="${chartResource.title || '图表'}" style="max-width: 100%; height: auto; max-height: 400px;" />
        </div>
      `
    }
    return `[图表 ${chartId} 未找到]`
  })

  return result
}
```

## 测试计划

1. **功能测试**：
   - 验证行间距设置是否正确应用
   - 验证段落缩进设置是否正确应用
   - 验证标题样式是否正确应用
   - 验证表格样式是否正确应用

2. **性能测试**：
   - 测试大量内容时的渲染性能
   - 验证样式变化时的响应速度

3. **兼容性测试**：
   - 验证新旧配置结构的兼容性
   - 测试各种边界情况

## 预期效果

实施完成后，预览区将能够：
- 正确应用所有样式设置，包括行间距和段落缩进
- 支持动态样式更新，实时反映配置变化
- 保持良好的渲染性能
- 提供一致的视觉体验
- 完全兼容新旧配置结构

## 风险与对策

1. **性能风险**：大量样式计算可能影响性能
   - 对策：使用 useMemo 缓存计算结果

2. **兼容性风险**：新代码可能破坏现有功能
   - 对策：保持向后兼容，充分测试

3. **复杂性风险**：代码复杂度增加
   - 对策：良好的文档和注释，模块化设计