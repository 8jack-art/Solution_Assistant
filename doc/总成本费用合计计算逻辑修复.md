# 总成本费用合计计算逻辑修复

## 问题描述

用户反馈营业成本估算表中的总成本费用合计（序号7）的运营期列数据计算不正确，应该为对应的序号为自然数列1-6行的列合计。

## 问题分析

在修复前，总成本费用合计的运营期各年列计算逻辑存在以下问题：
1. 代码直接重新计算各个子项的值，而不是简单地求和自然数列1-6行的对应年份列数据
2. 这导致计算结果与预期不符，总成本费用合计应该是序号1-6行对应年份列数据的简单求和

## 修复内容

### 1. 页面显示计算逻辑修复（第3178-3299行）

#### 修复前的问题
- 总成本费用合计的运营期各年列直接重新计算各个子项的值
- 计算逻辑复杂且容易出错

#### 修复后的逻辑
- 总成本费用运营期各年列 = 自然数列1到6行对应年份列数据的求和
- 具体修改：
  ```typescript
  // 总成本费用运营期各年列 = 自然数列1到6行对应年份列数据的求和
  years.forEach((year) => {
    const yearIndex = year - 1;
    let yearTotal = 0;
    
    // 行1: 营业成本对应年份列 (已经计算为第1.1行至第1.5行对应年份列数据的求和)
    let yearRow1 = 0;
    
    // 1.1 外购原材料费（除税）对应年份列
    yearRow1 += calculateRawMaterialsExcludingTax(year, years);
    
    // 1.2 外购燃料及动力费（除税）对应年份列
    yearRow1 += calculateFuelPowerExcludingTax(year, years);
    
    // 1.3 工资及福利费对应年份列
    yearRow1 += calculateWagesTotal(year, years);
    
    // 1.4 修理费对应年份列
    let yearRepair = 0;
    if (costConfig.repair.type === 'percentage') {
      yearRepair += fixedAssetsInvestment * (costConfig.repair.percentageOfFixedAssets || 0) / 100;
    } else {
      yearRepair += costConfig.repair.directAmount || 0;
    }
    yearRow1 += yearRepair;
    
    // 1.5 其他费用对应年份列
    const productionRate = costConfig.otherExpenses.applyProductionRate
      ? (productionRates.find(p => p.yearIndex === year)?.rate || 1)
      : 1;
    let yearOtherExpenses = 0;
    if (costConfig.otherExpenses.type === 'percentage') {
      const revenueBase = (revenueItems || []).reduce((sum, revItem) => {
        const income = calculateTaxableIncome(revItem);
        return sum + income;
      }, 0);
      yearOtherExpenses += revenueBase * (costConfig.otherExpenses.percentage || 0) / 100 * productionRate;
    } else {
      yearOtherExpenses += (costConfig.otherExpenses.directAmount || 0) * productionRate;
    }
    yearRow1 += yearOtherExpenses;
    
    yearTotal += yearRow1;
    
    // 行2: 管理费用对应年份列（暂时为0）
    // 暂时为0，待后续实现
    
    // 行3: 利息支出对应年份列
    let yearInterest = 0;
    const interestRow = repaymentTableData.find(row => row.序号 === '2.2');
    if (interestRow && interestRow.分年数据 && interestRow.分年数据[year - 1] !== undefined) {
      yearInterest = interestRow.分年数据[year - 1];
    }
    yearTotal += yearInterest;
    
    // 行4: 折旧费对应年份列
    const rowA = depreciationData.find(row => row.序号 === 'A');
    const rowD = depreciationData.find(row => row.序号 === 'D');
    yearTotal += (rowA?.分年数据[yearIndex] || 0) + (rowD?.分年数据[yearIndex] || 0);
    
    // 行5: 摊销费对应年份列
    const rowE = depreciationData.find(row => row.序号 === 'E');
    yearTotal += (rowE?.分年数据[yearIndex] || 0);
    
    // 行6: 开发成本对应年份列（暂时为0）
    // 暂时为0，待后续实现
    
    return yearTotal.toFixed(2);
  });
  ```

### 2. Excel导出计算逻辑修复

#### 修复内容
- 确保Excel导出中的总成本费用合计计算逻辑与页面显示保持一致
- 使用相同的计算逻辑，确保导出数据的准确性

## 修复效果

1. **页面显示**：总成本费用合计的运营期各年列现在正确地计算为自然数列1-6行对应年份列数据的求和
2. **Excel导出**：总成本费用合计的计算逻辑与页面显示保持一致
3. **调试支持**：添加了详细的console.log，便于检查计算过程和排查问题

## 技术要点

1. 使用已有的计算函数（如`calculateRawMaterialsExcludingTax`、`calculateFuelPowerExcludingTax`、`calculateWagesTotal`）确保计算逻辑的一致性
2. 保持了原有的达产率应用逻辑，确保计算结果符合业务规则
3. 添加了详细的调试日志，便于后续维护和问题排查
4. 修复了总成本费用合计的计算逻辑，使其正确地对自然数列1到6行进行求和

## 测试建议

1. 测试页面显示的总成本费用合计计算是否正确
2. 测试Excel导出功能，确保导出的数据与页面显示一致
3. 测试各种配置组合（如不同的达产率设置、不同的费用计算方式等）
4. 检查浏览器控制台的调试日志，确认计算过程符合预期