# 财务计算指标表数据一致性修复计划

## 问题描述

项目方案导出模块中，`{{DATA:financial_indicators}}` 变量数据不一致：
- ✅ 点击小眼睛查看的JSON数据（正确）
- ❌ LLM作为提示词输出的数据（错误）

## 问题分析

### 问题根源

在 [`reportStore.ts`](client/src/stores/reportStore.ts) 中存在两次调用 `buildAllTableDataJSON()` 的逻辑：

1. **第484行** (`loadProjectData`函数)：用于构建 `availableVariables`，显示在小眼睛中
2. **第594行** (`startGeneration`函数)：用于LLM生成时传递数据

```typescript
// loadProjectData 中 - 构建变量供小眼睛使用
const tableDataJSON = buildAllTableDataJSON(projectData)

// startGeneration 中 - 重新构建用于LLM生成
const tableDataJSON = projectData ? buildAllTableDataJSON(projectData) : {}
```

如果两次调用时 `projectData` 数据状态不同，或者构建逻辑有细微差异，就会导致数据不一致。

## 修复方案

### 核心思路

**缓存 tableDataJSON**：将 `loadProjectData` 中构建的 `tableDataJSON` 缓存起来，在 `startGeneration` 中直接使用缓存数据，避免重复构建导致的不一致。

### 实施步骤

#### 步骤1：添加缓存字段

在 `ReportState` 接口中添加 `cachedTableDataJSON` 字段：

```typescript
cachedTableDataJSON: Record<string, string>  // 缓存的表格数据JSON（用于LLM提示词）
```

#### 步骤2：实现获取方法

添加 `getCachedTableDataJSON` 方法声明：

```typescript
getCachedTableDataJSON: () => Record<string, string>
```

#### 步骤3：初始化缓存字段

在 `useReportStore` 初始状态中初始化：

```typescript
cachedTableDataJSON: {},
```

#### 步骤4：保存缓存数据

在 `loadProjectData` 中，将构建的 `tableDataJSON` 保存到缓存：

```typescript
set((state) => ({ 
  projectData: projectData,
  availableVariables: variables,
  cachedTableDataJSON: tableDataJSON,  // 缓存tableDataJSON
  resources: { ...state.resources, tables },
  isLoading: false 
}))
```

#### 步骤5：使用缓存数据

修改 `startGeneration`，优先使用缓存的 `tableDataJSON`：

```typescript
startGeneration: async () => {
  const { projectId, promptTemplate, reportTitle, projectData, cachedTableDataJSON } = get()
  
  // ... 验证逻辑 ...
  
  // 使用缓存的 tableDataJSON，确保与小眼睛查看的数据一致
  let tableDataJSON = cachedTableDataJSON || {}
  if (Object.keys(tableDataJSON).length === 0 && projectData) {
    tableDataJSON = buildAllTableDataJSON(projectData)
    console.log('[startGeneration] 缓存为空，重新构建 tableDataJSON')
  }
  
  // 后续逻辑不变...
}
```

#### 步骤6：重置时清理缓存

在 `resetReport` 中重置缓存：

```typescript
resetReport: () => {
  set({
    // ...其他字段...
    cachedTableDataJSON: {}  // 重置缓存的 tableDataJSON
  })
},
```

## 修改文件清单

| 文件 | 修改内容 |
|------|----------|
| `client/src/stores/reportStore.ts` | 添加缓存字段、修改 `loadProjectData`、`startGeneration`、`resetReport` |

## 验证步骤

1. 加载项目数据，查看小眼睛中的 `{{DATA:financial_indicators}}` 数据
2. 使用LLM生成报告，对比两者数据是否一致
3. 检查控制台是否有 `[startGeneration]` 相关日志

## 完成状态

✅ 已完成所有修改

---

# 补充修复：投资估算简表JSON精度保留

## 问题描述

用户反馈：`{{DATA:investment_estimate}}` JSON数据中的金额值精度被截断为2位小数（如 1300.61），但数据库中的原始数据有很多位小数。

## 问题分析

### 问题根源

后端 [`tableDataBuilder.ts`](server/src/utils/tableDataBuilder.ts) 中有两个地方在截断精度：

1. **`formatNumber2` 函数**（第24-27行）：将所有数值截断为2位小数
   ```typescript
   const formatNumber2 = (value: any): string => {
     const num = Number(value)
     return isNaN(num) ? '' : num.toFixed(2)  // ❌ 截断为2位小数
   }
   ```

2. **`toFixed2` 函数**（第1171-1172行）：在财务计算指标表构建中也截断精度
   ```typescript
   const toFixed2 = (value: number): number => Number(value.toFixed(2))
   ```

## 修复方案

### 实施步骤

#### 步骤1：修改 formatNumber2 函数

修改 `formatNumber2` 函数，保留原始精度：

```typescript
/**
 * 辅助函数：安全获取原始数值（保留原始精度，不截断）
 */
const formatNumber2 = (value: any): any => {
  if (value === null || value === undefined || value === '') {
    return ''
  }
  const num = Number(value)
  if (isNaN(num)) {
    return ''
  }
  return num  // ✅ 返回原始数值，不截断
}
```

#### 步骤2：修改 toFixed2 函数

修改 `toFixed2` 函数，保留原始精度：

```typescript
// 辅助函数：保留原始数值（不截断精度）
const toFixed2 = (value: number): number => value  // ✅ 返回原始数值
```

## 修改文件清单

| 文件 | 修改内容 |
|------|----------|
| `server/src/utils/tableDataBuilder.ts` | 修改 `formatNumber2` 和 `toFixed2` 函数，移除精度截断 |
| `client/src/utils/tableResourceBuilder.ts` | 修改 `buildInvestmentEstimateJSON` 函数，移除 `formatNumber2` 调用 |

## 验证步骤

1. 加载项目数据，查看 `{{DATA:investment_estimate}}` JSON数据
2. 验证金额字段（如 建设工程费、设备购置费、合计 等）是否保留了原始精度
3. 对比数据库中的原始数据，确认精度一致

## 完成状态

✅ 已完成后端精度保留修复

✅ 已完成前端浮点数精度校正

---

# 补充修复：前端浮点数精度校正

## 问题描述

移除精度截断后，JavaScript 浮点数计算会出现精度问题，例如：
- `0.1 + 0.2 = 0.30000000000000004`
- `3251.5499999999997` 而不是 `3251.55`

## 修复方案

### 前端修改

在 [`tableResourceBuilder.ts`](client/src/utils/tableResourceBuilder.ts) 中：

1. **修改 `formatNumber2` 函数**：添加浮点数精度校正

```typescript
const formatNumber2 = (value: any, defaultValue: string = '0.00'): string => {
  if (value === null || value === undefined || value === '') {
    return defaultValue
  }
  const num = Number(value)
  if (isNaN(num)) {
    return defaultValue
  }
  // 浮点数精度校正：解决 0.1 + 0.2 = 0.30000000000000004 问题
  const corrected = parseFloat(num.toFixed(10))
  return corrected.toFixed(2)
}
```

2. **添加 `getNumberValue` 函数**：用于保留原始精度的数值获取

```typescript
const getNumberValue = (value: any): any => {
  if (value === null || value === undefined || value === '') {
    return 0
  }
  const num = Number(value)
  if (isNaN(num)) {
    return 0
  }
  // 浮点数精度校正
  return parseFloat(num.toFixed(10))
}
```

3. **修改 `buildInvestmentEstimateJSON` 函数**：使用 `getNumberValue` 替代直接取值

```typescript
summary: {
  totalInvestment: getNumberValue(estimateData.partG?.合计),
  // ... 其他字段
},
partA: {
  total: getNumberValue(estimateData.partA?.合计),
  children: estimateData.partA?.children?.map((item: any) => ({
    建设工程费: getNumberValue(item['建设工程费（万元）'] ?? item.建设工程费),
    // ... 其他字段
  }))
}
```

### 后端修改

在 [`tableDataBuilder.ts`](server/src/utils/tableDataBuilder.ts) 中：

1. **修改 `formatNumber2` 函数**：添加浮点数精度校正

```typescript
const formatNumber2 = (value: any): any => {
  if (value === null || value === undefined || value === '') {
    return ''
  }
  const num = Number(value)
  if (isNaN(num)) {
    return ''
  }
  // Float precision correction:解决 0.1 + 0.2 = 0.30000000000000004 问题
  const corrected = parseFloat(num.toFixed(10))
  return corrected
}
```

## 修改文件清单

| 文件 | 修改内容 |
|------|----------|
| `client/src/utils/tableResourceBuilder.ts` | 添加 `getNumberValue` 函数，修改 `buildInvestmentEstimateJSON` |
| `server/src/utils/tableDataBuilder.ts` | 修改 `formatNumber2` 函数，添加浮点数精度校正 |

## 验证步骤

1. 加载项目数据，查看 `{{DATA:investment_estimate}}` JSON数据
2. 验证金额字段没有浮点数精度问题（如 3251.55 而不是 3251.5499999999997）
3. 验证计算结果正确（如 1300.55 + 975.46 = 2276.01）

## 完成状态

✅ 已完成前端浮点数精度校正
✅ 已完成后端浮点数精度校正
